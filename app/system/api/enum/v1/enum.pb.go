// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.0
// source: enum/v1/enum.proto

package v1

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GetByTypeAndCodeReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// 枚举类型
	EnumType string `protobuf:"bytes,1,opt,name=enumType,proto3" json:"enumType,omitempty" dc:"枚举类型" v:"required#枚举类型不能为空"` // v:required#枚举类型不能为空
	// 枚举编码
	EnumCode      string `protobuf:"bytes,2,opt,name=enumCode,proto3" json:"enumCode,omitempty" dc:"枚举编码" v:"required#枚举编码不能为空"` // v:required#枚举编码不能为空
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetByTypeAndCodeReq) Reset() {
	*x = GetByTypeAndCodeReq{}
	mi := &file_enum_v1_enum_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetByTypeAndCodeReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetByTypeAndCodeReq) ProtoMessage() {}

func (x *GetByTypeAndCodeReq) ProtoReflect() protoreflect.Message {
	mi := &file_enum_v1_enum_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetByTypeAndCodeReq.ProtoReflect.Descriptor instead.
func (*GetByTypeAndCodeReq) Descriptor() ([]byte, []int) {
	return file_enum_v1_enum_proto_rawDescGZIP(), []int{0}
}

func (x *GetByTypeAndCodeReq) GetEnumType() string {
	if x != nil {
		return x.EnumType
	}
	return ""
}

func (x *GetByTypeAndCodeReq) GetEnumCode() string {
	if x != nil {
		return x.EnumCode
	}
	return ""
}

type GetByTypeAndCodeRes struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// 枚举值，如 1
	EnumValue string `protobuf:"bytes,1,opt,name=enumValue,proto3" json:"enumValue,omitempty" dc:"枚举值，如 1"`
	// 前端展示文本
	EnumLabel string `protobuf:"bytes,2,opt,name=enumLabel,proto3" json:"enumLabel,omitempty" dc:"前端展示文本"`
	// 枚举值说明
	EnumValueDesc string `protobuf:"bytes,3,opt,name=enumValueDesc,proto3" json:"enumValueDesc,omitempty" dc:"枚举值说明"`
	// 顺序
	Sort          int64 `protobuf:"varint,4,opt,name=sort,proto3" json:"sort,omitempty" dc:"顺序"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetByTypeAndCodeRes) Reset() {
	*x = GetByTypeAndCodeRes{}
	mi := &file_enum_v1_enum_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetByTypeAndCodeRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetByTypeAndCodeRes) ProtoMessage() {}

func (x *GetByTypeAndCodeRes) ProtoReflect() protoreflect.Message {
	mi := &file_enum_v1_enum_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetByTypeAndCodeRes.ProtoReflect.Descriptor instead.
func (*GetByTypeAndCodeRes) Descriptor() ([]byte, []int) {
	return file_enum_v1_enum_proto_rawDescGZIP(), []int{1}
}

func (x *GetByTypeAndCodeRes) GetEnumValue() string {
	if x != nil {
		return x.EnumValue
	}
	return ""
}

func (x *GetByTypeAndCodeRes) GetEnumLabel() string {
	if x != nil {
		return x.EnumLabel
	}
	return ""
}

func (x *GetByTypeAndCodeRes) GetEnumValueDesc() string {
	if x != nil {
		return x.EnumValueDesc
	}
	return ""
}

func (x *GetByTypeAndCodeRes) GetSort() int64 {
	if x != nil {
		return x.Sort
	}
	return 0
}

type GetByTypeReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          []string               `protobuf:"bytes,1,rep,name=Type,proto3" json:"Type,omitempty" v:"required|min-length:1#枚举类型不能为空|至少需要一个枚举类型"` // v:required|min-length:1#枚举类型不能为空|至少需要一个枚举类型
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetByTypeReq) Reset() {
	*x = GetByTypeReq{}
	mi := &file_enum_v1_enum_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetByTypeReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetByTypeReq) ProtoMessage() {}

func (x *GetByTypeReq) ProtoReflect() protoreflect.Message {
	mi := &file_enum_v1_enum_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetByTypeReq.ProtoReflect.Descriptor instead.
func (*GetByTypeReq) Descriptor() ([]byte, []int) {
	return file_enum_v1_enum_proto_rawDescGZIP(), []int{2}
}

func (x *GetByTypeReq) GetType() []string {
	if x != nil {
		return x.Type
	}
	return nil
}

type GetByTypeRes struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// 用户状态选项列表 - 使用 map 来存储不同类型的用户状态配置
	UserStatusMap map[string]*GetByTypeOptionList `protobuf:"bytes,1,rep,name=user_status_map,json=userStatusMap,proto3" json:"user_status_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value" dc:"用户状态选项列表 - 使用 map 来存储不同类型的用户状态配置"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetByTypeRes) Reset() {
	*x = GetByTypeRes{}
	mi := &file_enum_v1_enum_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetByTypeRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetByTypeRes) ProtoMessage() {}

func (x *GetByTypeRes) ProtoReflect() protoreflect.Message {
	mi := &file_enum_v1_enum_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetByTypeRes.ProtoReflect.Descriptor instead.
func (*GetByTypeRes) Descriptor() ([]byte, []int) {
	return file_enum_v1_enum_proto_rawDescGZIP(), []int{3}
}

func (x *GetByTypeRes) GetUserStatusMap() map[string]*GetByTypeOptionList {
	if x != nil {
		return x.UserStatusMap
	}
	return nil
}

type GetByTypeOptionList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Options       []*GetByTypeOption     `protobuf:"bytes,1,rep,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetByTypeOptionList) Reset() {
	*x = GetByTypeOptionList{}
	mi := &file_enum_v1_enum_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetByTypeOptionList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetByTypeOptionList) ProtoMessage() {}

func (x *GetByTypeOptionList) ProtoReflect() protoreflect.Message {
	mi := &file_enum_v1_enum_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetByTypeOptionList.ProtoReflect.Descriptor instead.
func (*GetByTypeOptionList) Descriptor() ([]byte, []int) {
	return file_enum_v1_enum_proto_rawDescGZIP(), []int{4}
}

func (x *GetByTypeOptionList) GetOptions() []*GetByTypeOption {
	if x != nil {
		return x.Options
	}
	return nil
}

// 枚举元素
type GetByTypeOption struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// 枚举编码，如 ADMIN
	EnumCode string `protobuf:"bytes,1,opt,name=enumCode,proto3" json:"enumCode,omitempty" dc:"枚举编码，如 ADMIN"`
	// 枚举值，如 1
	EnumValue string `protobuf:"bytes,2,opt,name=enumValue,proto3" json:"enumValue,omitempty" dc:"枚举值，如 1"`
	// 前端展示文本
	EnumLabel string `protobuf:"bytes,3,opt,name=enumLabel,proto3" json:"enumLabel,omitempty" dc:"前端展示文本"`
	// 枚举值说明
	EnumValueDesc string `protobuf:"bytes,4,opt,name=enumValueDesc,proto3" json:"enumValueDesc,omitempty" dc:"枚举值说明"`
	// 顺序
	Sort          int64 `protobuf:"varint,5,opt,name=sort,proto3" json:"sort,omitempty" dc:"顺序"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetByTypeOption) Reset() {
	*x = GetByTypeOption{}
	mi := &file_enum_v1_enum_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetByTypeOption) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetByTypeOption) ProtoMessage() {}

func (x *GetByTypeOption) ProtoReflect() protoreflect.Message {
	mi := &file_enum_v1_enum_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetByTypeOption.ProtoReflect.Descriptor instead.
func (*GetByTypeOption) Descriptor() ([]byte, []int) {
	return file_enum_v1_enum_proto_rawDescGZIP(), []int{5}
}

func (x *GetByTypeOption) GetEnumCode() string {
	if x != nil {
		return x.EnumCode
	}
	return ""
}

func (x *GetByTypeOption) GetEnumValue() string {
	if x != nil {
		return x.EnumValue
	}
	return ""
}

func (x *GetByTypeOption) GetEnumLabel() string {
	if x != nil {
		return x.EnumLabel
	}
	return ""
}

func (x *GetByTypeOption) GetEnumValueDesc() string {
	if x != nil {
		return x.EnumValueDesc
	}
	return ""
}

func (x *GetByTypeOption) GetSort() int64 {
	if x != nil {
		return x.Sort
	}
	return 0
}

var File_enum_v1_enum_proto protoreflect.FileDescriptor

const file_enum_v1_enum_proto_rawDesc = "" +
	"\n" +
	"\x12enum/v1/enum.proto\x12\aenum.v1\"M\n" +
	"\x13GetByTypeAndCodeReq\x12\x1a\n" +
	"\benumType\x18\x01 \x01(\tR\benumType\x12\x1a\n" +
	"\benumCode\x18\x02 \x01(\tR\benumCode\"\x8b\x01\n" +
	"\x13GetByTypeAndCodeRes\x12\x1c\n" +
	"\tenumValue\x18\x01 \x01(\tR\tenumValue\x12\x1c\n" +
	"\tenumLabel\x18\x02 \x01(\tR\tenumLabel\x12$\n" +
	"\renumValueDesc\x18\x03 \x01(\tR\renumValueDesc\x12\x12\n" +
	"\x04sort\x18\x04 \x01(\x03R\x04sort\"\"\n" +
	"\fGetByTypeReq\x12\x12\n" +
	"\x04Type\x18\x01 \x03(\tR\x04Type\"\xc0\x01\n" +
	"\fGetByTypeRes\x12P\n" +
	"\x0fuser_status_map\x18\x01 \x03(\v2(.enum.v1.GetByTypeRes.UserStatusMapEntryR\ruserStatusMap\x1a^\n" +
	"\x12UserStatusMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x122\n" +
	"\x05value\x18\x02 \x01(\v2\x1c.enum.v1.GetByTypeOptionListR\x05value:\x028\x01\"I\n" +
	"\x13GetByTypeOptionList\x122\n" +
	"\aoptions\x18\x01 \x03(\v2\x18.enum.v1.GetByTypeOptionR\aoptions\"\xa3\x01\n" +
	"\x0fGetByTypeOption\x12\x1a\n" +
	"\benumCode\x18\x01 \x01(\tR\benumCode\x12\x1c\n" +
	"\tenumValue\x18\x02 \x01(\tR\tenumValue\x12\x1c\n" +
	"\tenumLabel\x18\x03 \x01(\tR\tenumLabel\x12$\n" +
	"\renumValueDesc\x18\x04 \x01(\tR\renumValueDesc\x12\x12\n" +
	"\x04sort\x18\x05 \x01(\x03R\x04sort2\x91\x01\n" +
	"\x04Enum\x12N\n" +
	"\x10GetByTypeAndCode\x12\x1c.enum.v1.GetByTypeAndCodeReq\x1a\x1c.enum.v1.GetByTypeAndCodeRes\x129\n" +
	"\tGetByType\x12\x15.enum.v1.GetByTypeReq\x1a\x15.enum.v1.GetByTypeResB\x0fZ\r./api/enum/v1b\x06proto3"

var (
	file_enum_v1_enum_proto_rawDescOnce sync.Once
	file_enum_v1_enum_proto_rawDescData []byte
)

func file_enum_v1_enum_proto_rawDescGZIP() []byte {
	file_enum_v1_enum_proto_rawDescOnce.Do(func() {
		file_enum_v1_enum_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_enum_v1_enum_proto_rawDesc), len(file_enum_v1_enum_proto_rawDesc)))
	})
	return file_enum_v1_enum_proto_rawDescData
}

var file_enum_v1_enum_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_enum_v1_enum_proto_goTypes = []any{
	(*GetByTypeAndCodeReq)(nil), // 0: enum.v1.GetByTypeAndCodeReq
	(*GetByTypeAndCodeRes)(nil), // 1: enum.v1.GetByTypeAndCodeRes
	(*GetByTypeReq)(nil),        // 2: enum.v1.GetByTypeReq
	(*GetByTypeRes)(nil),        // 3: enum.v1.GetByTypeRes
	(*GetByTypeOptionList)(nil), // 4: enum.v1.GetByTypeOptionList
	(*GetByTypeOption)(nil),     // 5: enum.v1.GetByTypeOption
	nil,                         // 6: enum.v1.GetByTypeRes.UserStatusMapEntry
}
var file_enum_v1_enum_proto_depIdxs = []int32{
	6, // 0: enum.v1.GetByTypeRes.user_status_map:type_name -> enum.v1.GetByTypeRes.UserStatusMapEntry
	5, // 1: enum.v1.GetByTypeOptionList.options:type_name -> enum.v1.GetByTypeOption
	4, // 2: enum.v1.GetByTypeRes.UserStatusMapEntry.value:type_name -> enum.v1.GetByTypeOptionList
	0, // 3: enum.v1.Enum.GetByTypeAndCode:input_type -> enum.v1.GetByTypeAndCodeReq
	2, // 4: enum.v1.Enum.GetByType:input_type -> enum.v1.GetByTypeReq
	1, // 5: enum.v1.Enum.GetByTypeAndCode:output_type -> enum.v1.GetByTypeAndCodeRes
	3, // 6: enum.v1.Enum.GetByType:output_type -> enum.v1.GetByTypeRes
	5, // [5:7] is the sub-list for method output_type
	3, // [3:5] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_enum_v1_enum_proto_init() }
func file_enum_v1_enum_proto_init() {
	if File_enum_v1_enum_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_enum_v1_enum_proto_rawDesc), len(file_enum_v1_enum_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_enum_v1_enum_proto_goTypes,
		DependencyIndexes: file_enum_v1_enum_proto_depIdxs,
		MessageInfos:      file_enum_v1_enum_proto_msgTypes,
	}.Build()
	File_enum_v1_enum_proto = out.File
	file_enum_v1_enum_proto_goTypes = nil
	file_enum_v1_enum_proto_depIdxs = nil
}
